{"version":3,"file":"index.esm.js","sources":["../node_modules/_path-to-regexp@3.2.0@path-to-regexp/index.js","index.ts"],"sourcesContent":["/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.match = match\nmodule.exports.regexpToFunction = regexpToFunction\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var whitelist = (options && options.whitelist) || undefined\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n      var c = path[k]\n      var matches = whitelist ? whitelist.indexOf(c) > -1 : true\n\n      if (matches) {\n        prev = c\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var pattern = capture || group\n    var delimiter = prev || defaultDelimiter\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: pattern\n        ? escapeGroup(pattern)\n        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match (str, options) {\n  var keys = []\n  var re = pathToRegexp(str, keys, options)\n  return regexpToFunction(re, keys)\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction (re, keys) {\n  return function (pathname, options) {\n    var m = re.exec(pathname)\n    if (!m) return false\n\n    var path = m[0]\n    var index = m.index\n    var params = {}\n    var decode = (options && options.decode) || decodeURIComponent\n\n    for (var i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue\n\n      var key = keys[i - 1]\n\n      if (key.repeat) {\n        params[key.name] = m[i].split(key.delimiter).map(function (value) {\n          return decode(value, key)\n        })\n      } else {\n        params[key.name] = decode(m[i], key)\n      }\n    }\n\n    return { path: path, index: index, params: params }\n  }\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n    var validate = options ? options.validate !== false : true\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) continue\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = options.delimiter || DEFAULT_DELIMITER\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + escapeString(delimiter) + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    var endToken = tokens[tokens.length - 1]\n    var isEndDelimited = typeof endToken === 'string'\n      ? endToken[endToken.length - 1] === delimiter\n      : endToken === undefined\n\n    if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/*!\n *  omi-router v3.0.1 by dntzhang\n *  Router for Omi.\n *  Github: https://github.com/Tencent/omi\n *  MIT Licensed.\n */\n\nimport p2r from 'path-to-regexp'\nconst mapping = {}\nconst root = getGlobal()\n\nroot.route = route\nroot.route.params = null\nroot.historyLength = 0\n\nroot.route.to = function (path, data) {\n  root.route._routeByTo = true\n  root.route.data = data\n  if (path[0] === '#') {\n    location.hash = path\n  } else {\n    location.hash = '#' + path\n  }\n}\n\nwindow.addEventListener('hashchange', hashChange)\n\nexport function hashChange(evt) {\n  let byNative = false\n  //need to fix a line by omi-link\n  if (window.history.length === root.historyLength && !root.route._routeByTo) {\n    //keep alive mode\n    byNative = true\n  }\n  root.route._routeByTo = false\n  root.historyLength = window.history.length\n  let prevent = false\n  if (evt && evt.type === 'hashchange' && root.route.before) {\n    prevent = root.route.before(evt) === false\n  }\n  if (prevent) return\n  let path = window.location.hash.replace('#', '')\n  if (path === '') path = '/'\n  let notFound = true\n  Object.keys(mapping).every(function (key) {\n    const toArr = path.split('?')[0].match(mapping[key].reg)\n    if (toArr) {\n      let pathArr = key.match(mapping[key].reg)\n      root.route.params = getParams(toArr, pathArr)\n      root.route.query = getUrlParams(path)\n      mapping[key].callback({\n        params: root.route.params,\n        query: getUrlParams(path),\n        data: root.route.data,\n        byNative: byNative\n      })\n      root.route.data = null\n      notFound = false\n      return false\n    }\n    return true\n  })\n\n  if (notFound) {\n    mapping['*'] && mapping['*'].callback({ byNative: byNative })\n  }\n\n  if (evt && evt.type === 'hashchange' && root.route.after) {\n    root.route.after(evt)\n  }\n}\n\ndocument.addEventListener('DOMContentLoaded', hashChange)\n\nfunction getParams(toArr, pathArr) {\n  const params = {}\n  toArr.forEach(function (item, index) {\n    if (index > 0) {\n      params[pathArr[index].replace(':', '')] = item\n    }\n  })\n  return params\n}\n\n\n\nexport function route(path, callback) {\n  mapping[path] = {\n    callback: callback,\n    reg: p2r(path)\n  }\n}\n\nconst router = { route, hashChange }\nexport default router\n\nfunction getGlobal() {\n  if (\n    typeof global !== 'object' ||\n    !global ||\n    global.Math !== Math ||\n    global.Array !== Array\n  ) {\n    return (\n      self ||\n      window ||\n      global ||\n      (function () {\n        return this\n      })()\n    )\n  }\n  return global\n}\n\nfunction getUrlParams(url) {\n  url = url.replace(/#.*$/, '')\n  let queryArray = url.split(/[?&]/).slice(1)\n  let i, args = {}\n  for (i = 0; i < queryArray.length; i++) {\n    let match = queryArray[i].match(/([^=]+)=([^=]+)/)\n    if (match !== null) {\n      args[match[1]] = decodeURIComponent(match[2])\n    }\n  }\n  return args\n}\n"],"names":["p2r"],"mappings":"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"}